Pentru prima parte a cerintei am folosit un bloc try{}catch{} pentru a verifica daca argumentul oferit din linia de comanda este intr-adevar un int, iar daca utilizatorul incearca sa paseze altceva va primi mesajul "Argumentul nu este valid!" si executia se va opri. 
Crearea matricii de adiancenta a fost destul de simpla, folosind metoda "Math.random()" cu care am setat fiecare celula din matrice ca avand valoarea "Math.random()<2.0f/n", ce ne va oferi o distributie destul de buna incat sa nu avem doar un graf conex.
Testarea conexitatii grafului am facut-o folosind algoritmul DFS care porneste de la nodul '0' si merge catre toate nodurile la care are acces. Daca mai raman noduri nevizitate, atunci vom cauta primul nod nevizitat si vom face dfs pe acesta, iar procesul va fi repetat pana cand fiecare nod a fost vizitat.
Daca variabila "indexComponenta" este mai mare decat 1, asta inseamna ca avem componente conexe pe care le vom afisa, iar daca aceasta este 1, avem un graf conex si vom afisa matricea de adiacenta a arborelui partial.
Arborele partial este declarat la inceputul programului si construit in timp ce se executa functia DFS.
La inceputul programului facem o verificare pentru a vedea daca n este mai mare de 1000, caz in care oprim afisarile si vom printa doar timpul de executie a programului in nanosecunde. Pentru un n=30_000 am avut un timp de executie de 21360260100 nanosecunde pe un Intel i5-7300HQ
